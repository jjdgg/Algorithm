
# [BOJ 1010] 다리 놓기

## 문제 링크  
[https://www.acmicpc.net/problem/1010](https://www.acmicpc.net/problem/1010)  
📌 분류: `Combinatorics`, `Dynamic Programming (DP)` | 난이도: 실버 5

---

## 성능 요약  
- 메모리: 32,412 KB  
- 시간: 36 ms  

---

## 구분  
- 백준 온라인 저지 > 조합론 / 동적 계획법

---

## 문제 설명  

서쪽에 N개의 사이트, 동쪽에 M개의 사이트가 주어졌을 때,  
N개의 다리를 서로 겹치지 않게 놓는 경우의 수를 구하는 문제입니다.  

단, 한 사이트에는 한 개의 다리만 연결될 수 있고, 다리는 겹치지 않아야 합니다.

즉, M개의 동쪽 사이트 중 N개를 선택하는 **조합(C(M, N))** 문제로 귀결됩니다.

---

## 제한사항  
- 0 < N ≤ M < 30  
- 테스트케이스 T는 1 이상 100 이하

---

## 입출력 예  

| 입력 | 출력 |
|------|------|
| 3<br>2 2<br>1 5<br>13 29 | 1<br>5<br>67863915 |

---

## 입출력 예 설명  

- 2 2 → C(2, 2) = 1  
- 1 5 → C(5, 1) = 5  
- 13 29 → C(29, 13) = 67863915  

---

## 풀이 후기

처음 문제를 봤을 때 조합 공식을 직접 구현하거나 라이브러리를 사용하는 방법도 생각했지만,  
이 문제는 테스트케이스가 많고 계산 범위도 작기 때문에 **동적 계획법(DP)**을 이용한 조합 계산이 효율적입니다.

따라서 **파스칼의 삼각형 점화식**을 사용하여 DP 테이블을 미리 채우고,  
테스트케이스마다 빠르게 정답을 출력하도록 구현했습니다.

---

## 최종 코드 – ✅ 동적 프로그래밍(DP)
```python
import sys
input = sys.stdin.readline

t = int(input())
dp = [[0] * 31 for _ in range(31)]

for i in range(31):
    dp[i][0] = 1
    dp[i][i] = 1

for i in range(2, 31):
    for j in range(1, i):
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j]

for _ in range(t):
    n, m = map(int, input().split())
    print(dp[m][n])
```

---

## 핵심 아이디어

- `dp[m][n] = mCn = m-1Cn-1 + m-1Cn` 점화식을 이용한 **조합 계산**
- 모든 조합 값을 `dp[0~30][0~30]`까지 미리 계산
- 각 테스트케이스는 O(1)로 해결 → 빠르고 정확함

---

## 🏁 결과 요약

| 항목 | 값 |
|------|----|
| 결과 | 맞았습니다!! |
| 시간 | 36 ms |
| 메모리 | 32,412 KB |
| 제출 번호 | 95379240 |
| 언어 | Python 3 |
| 정확성 | 100.0 / 100.0 |
