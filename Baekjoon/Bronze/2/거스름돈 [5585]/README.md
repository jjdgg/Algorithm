
# [BOJ 5585] 거스름돈

## 문제 링크  
[https://www.acmicpc.net/problem/5585](https://www.acmicpc.net/problem/5585)  
📌 분류: `Greedy` | 난이도: 브론즈 2

---

## 성능 요약  
- 메모리: 32412 KB  
- 시간: 32 ms  

---

## 구분  
- 백준 온라인 저지 > 그리디 알고리즘

---

## 문제 설명  

타로는 자주 가는 편의점에서 자신이 지불해야 할 금액보다 100엔 더 많이 냅니다.  
그리고 항상 **가장 적은 개수의 잔돈**을 받습니다.  

예를 들어, 380엔을 지불해야 한다면 1000엔을 내고, 620엔의 잔돈을 받습니다.  
잔돈을 줄 때는 아래의 **동전 단위**를 사용하며, 가능한 한 **적은 수의 동전**을 줘야 합니다:

- 500엔, 100엔, 50엔, 10엔, 5엔, 1엔

주어진 가격을 입력받아, 타로가 받게 될 **잔돈의 동전 개수의 최솟값**을 출력하세요.

---

## 제한사항  
- 입력은 항상 1 이상 99 이하 (단위: 엔)

---

## 입출력 예  

| 입력 | 출력 |
|------|------|
| 380 | 4 |
| 1   | 15 |

---

## 입출력 예 설명  

- 1000 - 380 = 620  
  → 500엔 1개, 100엔 1개, 10엔 2개 → 총 4개

- 1000 - 1 = 999  
  → 동전 조합 최솟값으로 구성하면 15개

---

## 풀이 후기

이 문제는 **전형적인 그리디(Greedy)** 문제입니다.  
큰 동전부터 차례대로 최대한 사용해가며 잔돈을 줄이면, 동전 개수의 최솟값을 구할 수 있습니다.  

단순하면서도 **그리디 전략의 기본 원칙**을 연습하기에 좋은 문제입니다.

---

## 최종 코드 –  그리디 알고리즘
```python
price = int(input())
change = 1000 - price
coins = [500, 100, 50, 10, 5, 1]

count = 0
for coin in coins:
    count += change // coin
    change %= coin

print(count)
```

---

## 핵심 아이디어

- 가장 큰 단위 동전부터 차례대로 사용할 수 있는 만큼 최대한 사용
- 남은 금액은 다음 작은 동전으로 해결
- 이 과정을 반복하면 **항상 최적해(최소 개수)**를 구할 수 있음

---

## 🏁 결과 요약

| 항목 | 값 |
|------|----|
| 결과 | 맞았습니다!! |
| 시간 | 32 ms |
| 메모리 | 32,412 KB |
| 언어 | Python 3 |
| 정확성 | 100.0 / 100.0 |
